Bill Pugh Singleton Pattern (Static Inner Class Singleton)
This is one of the best and most recommended ways to implement a Singleton in Java.
It combines the benefits of lazy instantiation and thread safety without requiring synchronized blocks.
________________________________________
ğŸ“Œ How It Works
In this approach, we use a static nested class (also called a static inner class) to hold the singleton instance.
Key Idea:
â€¢	The outer class is loaded when the program first references it.
â€¢	But the inner class is NOT loaded until it is referenced.
â€¢	When the inner class loads, it creates the Singleton object using eager instantiation, but this happens only when needed.
Thus, it becomes:
â€¢	Lazy Instantiation for the outer class object
â€¢	Eager Instantiation inside the inner class
This gives the best of both worlds.
________________________________________
ğŸ“ Code
public class Printer {

    // Private constructor
    private Printer() {
        System.out.println("Printer :: 0-param constructor");
    }

    // Static Inner Class (Nested Class)
    private static class PrinterInner {

        // Eager instantiation inside inner class
        private static final Printer INSTANCE = new Printer();
        /*
         * Note:
         * The Singleton object is created inside the inner class.
         * The inner class is loaded only when it is first accessed
         * through the outer class static factory method.
         * This means:
         * â†’ Lazy Loading for outer class
         * â†’ Eager Instantiation inside inner class
         * â†’ 100% thread-safe without synchronized
         */
    }

    // Static Factory Method
    public static Printer getInstance() {
        return PrinterInner.INSTANCE;
    }

    // Business method
    public void printmsg(String msg) {
        System.out.println(msg);
    }
}
________________________________________
ğŸ” Why This Approach Is Powerful?
________________________________________

âœ” Lazy Initialization
Outer class loads, but Singleton object is created only when getInstance() is called.
âœ” Thread-Safe
Class loading in Java is thread-safe by design.
No need for synchronized, volatile, or double-checked locking.
âœ” High Performance
No synchronization overheadâ€”only one class-loading operation.
________________________________________
ğŸŸ© Advantages

â€¢	Simple and clean implementation
â€¢	Lazy loading supported
â€¢	Thread-safe without additional code
â€¢	No performance cost
â€¢	Recommended by many Java experts
________________________________________
ğŸŸ¥ Disadvantages
â€¢	None major â€” this is considered one of the best Singleton patterns
