üîê Serialization, Deserialization & Singleton ‚Äî Complete Guide
1Ô∏è‚É£ What is Serialization?
Serialization is the process of converting a Java object into a byte stream so that it can be:
‚Ä¢	Stored in a file
‚Ä¢	Sent over a network
‚Ä¢	Cached or persisted for later use
‚úî To enable serialization, a class must implement java.io.Serializable (a marker interface with no methods).
________________________________________
2Ô∏è‚É£ What is Deserialization?
Deserialization is the reverse process:
‚Ä¢	Reading a byte stream
‚Ä¢	Converting it back into a Java object
‚ö†Ô∏è Important:
During deserialization:
‚Ä¢	The constructor is NOT called
‚Ä¢	Object fields are restored directly from the byte data
This is why deserialization can break Singleton.
________________________________________
3Ô∏è‚É£ How Serialization Breaks the Singleton Pattern
Even if a class is a Singleton, if it implements Serializable, then:
1.	Serialize the Singleton ‚Üí its state is written to a file
2.	Deserialize ‚Üí JVM creates a new object instance
‚û°Ô∏è Now you have two objects ‚Üí Singleton is broken.
________________________________________
4Ô∏è‚É£ Why JVM Creates a New Object During Deserialization?
Because the deserialization process completely bypasses the constructor.
JVM steps:
‚Ä¢	Create a new instance (without constructor)
‚Ä¢	Populate fields with serialized data
‚Ä¢	Do not call the private constructor
Diagram:
Singleton Instance  
      ‚Üì Serialization  
   [file/bytes]  
      ‚Üë Deserialization  
 ‚Üí NEW OBJECT (constructor not called)
________________________________________
5Ô∏è‚É£ How to Fix Singleton + Serialization Issue?
‚úî Option 1: Use readResolve()
private Object readResolve() {
    return INSTANCE; // return the existing Singleton instance
}
üîπ JVM automatically calls readResolve() after deserialization
üîπ It replaces the newly created object with the original Singleton instance
üîπ Keeps Singleton intact
________________________________________
‚ùå Option 2: Block Deserialization (rarely used)
private Object readResolve() {
    throw new IllegalArgumentException("Deserialization not allowed");
}
________________________________________
6Ô∏è‚É£ What is serialVersionUID and Why It‚Äôs Needed?
Always declare:
private static final long serialVersionUID = 1L;
‚úî Ensures backward compatibility
‚úî Prevents InvalidClassException when class structure changes
‚úî Without it, JVM auto-generates a UID ‚Üí leads to mismatch issues
________________________________________
7Ô∏è‚É£ Why Should Singleton Classes Avoid Serializable?
If a Singleton class (or its parent class) implements Serializable, then:
‚Ä¢	Deserialization creates new instances
‚Ä¢	Singleton is broken
‚Ä¢	Use readResolve() to prevent this
________________________________________
8Ô∏è‚É£ Spring Singleton ‚â† Java Singleton
Spring @Singleton	Java Singleton
One instance per Spring container	One instance per JVM
Framework-managed	Language-level design pattern
You can still create new objects using new	Constructor is private
Spring Singleton is not a true Java Singleton.
________________________________________
9Ô∏è‚É£ What is readResolve() / writeReplace() ?
‚úî readResolve()
‚Ä¢	Automatically called during deserialization
‚Ä¢	Allows replacing the newly created object with a different object
‚Ä¢	Used to preserve Singleton property
‚úî writeReplace()
‚Ä¢	Automatically called during serialization
‚Ä¢	Allows returning a different object to be serialized
üìå These methods do not belong to any interface
They are special hooks used internally by Java‚Äôs serialization mechanism.
________________________________________
üìù Summary (Perfect for README.md)
‚Ä¢	Serialization ‚Üí Java object ‚Üí bytes
‚Ä¢	Deserialization ‚Üí bytes ‚Üí Java object (constructor not called)
‚Ä¢	Singleton Breaks because deserialization creates new object
‚Ä¢	Fix ‚Üí implement readResolve()
‚Ä¢	serialVersionUID ‚Üí prevents compatibility issues
‚Ä¢	Spring Singleton ‚â† Java Singleton

