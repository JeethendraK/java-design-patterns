1Ô∏è‚É£ What is Serialization?
Serialization is the process of converting a Java object into a stream of bytes so that the object can be:
‚Ä¢	Saved into a file
‚Ä¢	Sent over the network
‚Ä¢	Stored for later use (caching, persistence, etc.)
‚úÖ Requirements
‚Ä¢	Only serializable objects can be serialized.
‚Ä¢	A class becomes serializable only when it implements the
java.io.Serializable interface ‚Üí (marker interface, contains no methods).
________________________________________
2Ô∏è‚É£ What is Deserialization?
Deserialization is the reverse process:
‚Ä¢	Reading the byte stream from a file or network
‚Ä¢	Reconstructing it into a Java object
‚ö†Ô∏è Important Behavior
During deserialization:
‚Ä¢	Constructor does NOT execute
‚Ä¢	Object fields are restored from the saved data
This is the key reason why deserialization can break the Singleton pattern.
________________________________________
3Ô∏è‚É£ How Serialization Breaks a Singleton?
Even if a class is a Singleton, if it implements Serializable, then:
1.	Serializing the singleton instance ‚Üí writes its state to a file
2.	Deserializing ‚Üí JVM creates a new object
This violates the Singleton principle because now there are two objects.
________________________________________
4Ô∏è‚É£ Why does JVM create a new object during Deserialization?
Because deserialization bypasses the constructor.
JVM internally:
‚Ä¢	Creates a new object
‚Ä¢	Fills it with the byte-stream data
‚Ä¢	Does NOT call the constructor
Diagram (cleaned):
   Java Application
      (Singleton instance)
            |
         Serialization
   (ObjectOutputStream)
            |
          FILE
    (stores bits & bytes)
            |
       Deserialization
   (ObjectInputStream)
            |
   NEW OBJECT CREATED
 (constructor NOT called)
________________________________________
5Ô∏è‚É£ How to Fix Singleton + Serialization Issue?
Use readResolve() method inside the Singleton class:
private Object readResolve() {
    return getInstance();
}
‚úî Why this works?
‚Ä¢	After deserialization, JVM calls readResolve()
‚Ä¢	Instead of returning the newly created object
‚Üí it returns the original Singleton instance
‚Ä¢	Duplicate object is discarded
Thus, Singleton behavior remains intact.
________________________________________
6Ô∏è‚É£ What is serialVersionUID and Why is it Required?
Always define:
private static final long serialVersionUID = 1L;
‚úî Why?
If you don‚Äôt define it:
‚Ä¢	JVM generates one automatically based on class structure
‚Ä¢	If you modify the class later (add field/remove field)
‚Ä¢	Deserialization fails with:
java.io.InvalidClassException:
local class incompatible:
stream class serialVersionUID = X,
local class serialVersionUID = Y
Defining serialVersionUID ensures backward compatibility across versions.
________________________________________
7Ô∏è‚É£ Why Should Singleton Classes Avoid Serializable?
‚Ä¢	If a Singleton class implements Serializable directly or indirectly (via parent class)
‚Ä¢	Deserialization can create multiple instances
‚Ä¢	This breaks Singleton unless you explicitly handle it using readResolve()
________________________________________
8Ô∏è‚É£ Spring Singleton ‚â† Java Singleton
‚úî Spring‚Äôs @Scope("singleton")
‚Ä¢	Creates one object per Spring container
‚Ä¢	NOT a true Java Singleton
‚Ä¢	You can still create multiple instances using new
‚úî Java Singleton
‚Ä¢	Ensures one instance in JVM
‚Ä¢	Controlled using private constructor + static instance
________________________________________
üìù SUMMARY (Perfect for GitHub)
üîπ Serialization
Converts Java object ‚Üí byte stream.
üîπ Deserialization
Converts byte stream ‚Üí Java object (constructor not called).
üîπ Singleton Break Issue
Deserialization creates a new object, breaking Singleton.
üîπ Fix
Use readResolve() in Singleton class:
private Object readResolve() {
    return getInstance();
}
üîπ serialVersionUID
Prevents InvalidClassException when class structure changes.

